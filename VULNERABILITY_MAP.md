# Vulnerability Map

## Overview
This document maps each vulnerability type to specific files and functions in the codebase, making it easier to understand the flow of vulnerable code that vulnhuntr will analyze.

## Vulnerability Distribution by File

### SQL Injection (SQLI)
```
app/models/user.py
├── find_by_username()      → String concatenation in WHERE clause
├── find_by_id()            → String formatting in WHERE clause
├── authenticate()          → Concatenated username AND password
├── search_users()          → User input in LIKE clause
└── update_profile()        → Dynamic UPDATE clause construction

app/models/document.py
├── find_by_id()            → String formatting in WHERE clause
├── search()                → Unparameterized LIKE query
├── delete()                → String formatting in DELETE
└── update()                → String concatenation in UPDATE

Entry Points:
- /auth/login
- /auth/search
- /docs/search
- /docs/view/<id>
- /api/search
```

### Insecure Direct Object Reference (IDOR)
```
app/models/document.py
├── find_by_id()            → No ownership verification
├── delete()                → No authorization check
└── update()                → No ownership validation

app/views/documents.py
├── /docs/view/<id>         → Calls find_by_id without auth
├── /docs/edit/<id>         → No ownership check
└── /docs/delete/<id>       → No authorization

app/views/api.py
├── /api/users/<id>         → Direct user access
└── /api/documents/<id>     → Direct document access

Call Chain Example:
GET /docs/view/2 → view_document() → Document.find_by_id(2) → SQL query
                                   (no check if current user owns doc 2)
```

### Local File Inclusion (LFI)
```
app/services/file_service.py
├── read_file()             → os.path.join with user input
├── read_file_absolute()    → Direct path from user
├── get_file_path()         → Path traversal via ../
└── list_files()            → User-specified directory

app/views/documents.py
├── /docs/download/<path>   → Uses get_file_path()
└── /docs/read_file         → Calls read_file() with query param

app/views/api.py
└── /api/file/read          → Accepts 'path' parameter

Call Chain Example:
GET /docs/read_file?file=../../../etc/passwd
    → read_file() 
    → FileService.read_file("../../../etc/passwd")
    → open("/tmp/../../../etc/passwd")
```

### Arbitrary File Overwrite (AFO)
```
app/services/file_service.py
├── write_file()            → No path validation
├── write_to_path()         → User controls full path
├── save_upload()           → Weak sanitization (bypassable)
└── delete_file()           → No path restriction

app/views/admin.py
└── /admin/write_file       → Calls write_to_path()

app/utils/network.py
└── download_file()         → SSRF + AFO combo

Call Chain Example:
POST /admin/write_file (path=/etc/cron.d/evil, content=payload)
     → write_file()
     → FileService.write_to_path("/etc/cron.d/evil", payload)
     → open("/etc/cron.d/evil", 'w')
```

### Remote Code Execution (RCE)
```
app/services/export.py
├── export_to_format()      → subprocess with shell=True
├── generate_report()       → Command injection in subprocess
├── evaluate_expression()   → eval() on user input
├── execute_template()      → exec() on user input
├── deserialize_settings()  → pickle.loads() on user data
└── run_export_script()     → Shell command injection

app/views/admin.py
├── /admin/export           → export_to_format()
├── /admin/generate_report  → generate_report()
├── /admin/evaluate         → evaluate_expression()
├── /admin/execute_template → execute_template()
└── /admin/deserialize      → deserialize_settings()

Call Chain Example:
GET /admin/evaluate?expr=__import__('os').system('id')
    → evaluate()
    → ExportService.evaluate_expression("__import__('os').system('id')")
    → eval("__import__('os').system('id')")
    → RCE
```

### Cross-Site Scripting (XSS)
```
app/utils/helpers.py
├── format_output()         → Unescaped HTML
├── render_content()        → User data in HTML
├── render_search_results() → Query in HTML without escaping
├── render_user_profile()   → User-controlled bio/website
├── create_html_element()   → Unescaped attributes
└── render_notification()   → JavaScript injection

app/views/auth.py
├── /auth/login             → Error message in HTML
├── /auth/profile           → Message parameter unescaped
└── /auth/search            → Query reflected in response

app/views/documents.py
├── /docs/view/<id>         → Document content unescaped
├── /docs/search            → Search query in HTML
└── /docs/read_file         → File content unescaped

Call Chain Example:
GET /auth/profile?message=<script>alert(1)</script>
    → profile()
    → return f"<div>{message}</div>"  (no escaping)
```

### Server-Side Request Forgery (SSRF)
```
app/utils/network.py
├── fetch_url()             → requests.get(user_url)
├── proxy_request()         → No URL validation
├── check_url_status()      → Can scan internal ports
├── download_file()         → Fetch from user URL
├── fetch_image()           → No content-type validation
├── validate_webhook_url()  → Weak blacklist
├── fetch_json_data()       → User-controlled headers
└── make_api_call()         → Can access internal APIs

app/views/admin.py
├── /admin/fetch_url        → fetch_url()
└── /admin/proxy            → proxy_request()

app/views/api.py
├── /api/webhook            → fetch_url()
└── /api/proxy              → fetch_url()

Call Chain Example:
GET /admin/fetch_url?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/
    → fetch_external_url()
    → fetch_url("http://169.254.169.254/...")
    → requests.get("http://169.254.169.254/...")
    → Access to AWS metadata
```

## Vulnerability Chains (Multi-Step)

### Chain 1: SSRF → AFO
```
/admin/fetch_url (SSRF) + download_file() → AFO
User can fetch internal file and save it anywhere
```

### Chain 2: SQLI → IDOR
```
/docs/search (SQLI) → enumerate doc IDs → /docs/view/<id> (IDOR)
SQL injection reveals all documents, IDOR allows access
```

### Chain 3: LFI → Information Disclosure → RCE
```
/docs/read_file (LFI) → read config files → extract secrets → /admin/evaluate (RCE)
```

### Chain 4: XSS → Session Hijacking
```
/auth/profile?message=<script> (XSS) → steal session cookie → IDOR exploitation
```

## Statistics

- **Total Python Files**: 17
- **Total Vulnerabilities**: 50+
- **Vulnerable Functions**: 40+
- **Entry Points**: 25+
- **Layers with Vulnerabilities**: 4 (Models, Services, Utils, Views)

## Testing Priority

1. **Start with Models**: SQLi and IDOR in base data access
2. **Service Layer**: RCE, LFI, AFO in business logic
3. **Utils Layer**: XSS and SSRF in helper functions
4. **Views Layer**: Entry points that chain to vulnerable functions

## Notes for Vulnhuntr

This application is designed to test vulnhuntr's ability to:

1. **Trace multi-layer call chains**: Vulnerabilities span 2-3 layers
2. **Identify data flows**: User input → View → Service → Model
3. **Detect bypass attempts**: Weak sanitization that can be circumvented
4. **Handle complex patterns**: Multiple paths to same vulnerability
5. **Recognize contexts**: Same function vulnerable in different contexts
